import{dn as L,bt as T,bP as E,dp as R,r as m,dq as U,dr as $}from"./index-rD5D3wIe.js";function x(t){return t!==void 0}function q(t,e){var n=e||{},i=n.defaultValue,r=n.value,a=n.onChange,c=n.postState,v=L(function(){return x(r)?r:x(i)?typeof i=="function"?i():i:typeof t=="function"?t():t}),h=T(v,2),s=h[0],l=h[1],f=r!==void 0?r:s,S=c?c(f):f,N=E(a),b=L([f]),C=T(b,2),d=C[0],w=C[1];R(function(){var o=d[0];s!==o&&N(s,o)},[d]),R(function(){x(r)||l(r)},[r]);var y=E(function(o,u){l(o,u),w([f],u)});return[S,y]}function j(){if(console&&console.warn){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];typeof e[0]=="string"&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e)}}const P={};function I(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];typeof e[0]=="string"&&P[e[0]]||(typeof e[0]=="string"&&(P[e[0]]=new Date),j(...e))}const F=(t,e)=>()=>{if(t.isInitialized)e();else{const n=()=>{setTimeout(()=>{t.off("initialized",n)},0),e()};t.on("initialized",n)}};function z(t,e,n){t.loadNamespaces(e,F(t,n))}function A(t,e,n,i){typeof n=="string"&&(n=[n]),n.forEach(r=>{t.options.ns.indexOf(r)<0&&t.options.ns.push(r)}),t.loadLanguages(e,F(t,i))}function k(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const i=e.languages[0],r=e.options?e.options.fallbackLng:!1,a=e.languages[e.languages.length-1];if(i.toLowerCase()==="cimode")return!0;const c=(v,h)=>{const s=e.services.backendConnector.state[`${v}|${h}`];return s===-1||s===2};return n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&e.services.backendConnector.backend&&e.isLanguageChangingTo&&!c(e.isLanguageChangingTo,t)?!1:!!(e.hasResourceBundle(i,t)||!e.services.backendConnector.backend||e.options.resources&&!e.options.partialBundledLanguages||c(i,t)&&(!r||c(a,t)))}function M(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return!e.languages||!e.languages.length?(I("i18n.languages were undefined or empty",e.languages),!0):e.options.ignoreJSONStructure!==void 0?e.hasLoadedNamespace(t,{lng:n.lng,precheck:(r,a)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&r.services.backendConnector.backend&&r.isLanguageChangingTo&&!a(r.isLanguageChangingTo,t))return!1}}):k(t,e,n)}const V=m.createContext();class O{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach(n=>{this.usedNamespaces[n]||(this.usedNamespaces[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const B=(t,e)=>{const n=m.useRef();return m.useEffect(()=>{n.current=e?n.current:t},[t,e]),n.current};function H(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const{i18n:n}=e,{i18n:i,defaultNS:r}=m.useContext(V)||{},a=n||i||$();if(a&&!a.reportNamespaces&&(a.reportNamespaces=new O),!a){I("You will need to pass in an i18next instance by using initReactI18next");const o=(p,g)=>typeof g=="string"?g:g&&typeof g=="object"&&typeof g.defaultValue=="string"?g.defaultValue:Array.isArray(p)?p[p.length-1]:p,u=[o,{},!1];return u.t=o,u.i18n={},u.ready=!1,u}a.options.react&&a.options.react.wait!==void 0&&I("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const c={...U(),...a.options.react,...e},{useSuspense:v,keyPrefix:h}=c;let s=t||r||a.options&&a.options.defaultNS;s=typeof s=="string"?[s]:s||["translation"],a.reportNamespaces.addUsedNamespaces&&a.reportNamespaces.addUsedNamespaces(s);const l=(a.isInitialized||a.initializedStoreOnce)&&s.every(o=>M(o,a,c));function f(){return a.getFixedT(e.lng||null,c.nsMode==="fallback"?s:s[0],h)}const[S,N]=m.useState(f);let b=s.join();e.lng&&(b=`${e.lng}${b}`);const C=B(b),d=m.useRef(!0);m.useEffect(()=>{const{bindI18n:o,bindI18nStore:u}=c;d.current=!0,!l&&!v&&(e.lng?A(a,e.lng,s,()=>{d.current&&N(f)}):z(a,s,()=>{d.current&&N(f)})),l&&C&&C!==b&&d.current&&N(f);function p(){d.current&&N(f)}return o&&a&&a.on(o,p),u&&a&&a.store.on(u,p),()=>{d.current=!1,o&&a&&o.split(" ").forEach(g=>a.off(g,p)),u&&a&&u.split(" ").forEach(g=>a.store.off(g,p))}},[a,b]);const w=m.useRef(!0);m.useEffect(()=>{d.current&&!w.current&&N(f),w.current=!1},[a,h]);const y=[S,a,l];if(y.t=S,y.i18n=a,y.ready=l,l||!l&&!v)return y;throw new Promise(o=>{e.lng?A(a,e.lng,s,()=>o()):z(a,s,()=>o())})}export{q as a,H as u};
